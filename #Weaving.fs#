module Weaving

//
// From the Functional Pearl
// "Weaving a Web" by Ralf Hinze and Johan Jeuring
//

type Term =
    | Var of string
    | Abs of string * Term
    | App of Term * Term
    | If of Term * Term * Term

//                         -> * <-
// n, if (= n) 0 then 1 else (+ n) (fac (pred n))
let rhs =
    Abs
        ("n",
         If
             (App(App(Var "=", Var "n"), Var "0"),
              Var "1",
              App(App(Var "+", Var "n"), (App(Var "fac", App(Var "pred", Var "n"))))))

type Ctx =
    | Top
    | Abs' of string * Ctx
    | App' of Ctx * Term
    | App'' of Term * Ctx
    | If' of Ctx * Term * Term
    | If'' of Term * Ctx * Term
    | If''' of Term * Term * Ctx

type at = { it: Term; ctx: Ctx }
type Loc = At of at

let down =
    function
    | At { it = Var s; ctx = c } -> At { it = Var s; ctx = c }
    | At { it = Abs (s, t); ctx = c } -> At { it = t; ctx = Abs'(s, c) }
    | At { it = App (f, a); ctx = c } -> At { it = f; ctx = App'(c, a) }
    | At { it = If (p, a, b); ctx = c } -> At { it = p; ctx = If'(c, a, b) }

let up =
    function
    | At { ctx = Top } as top -> top
    | At { it = t; ctx = Abs' (s, c) } -> At { it = Abs(s, t); ctx = c }
    | At { it = t; ctx = App' (c, e) } -> At { it = App(t, e); ctx = c }
    | At { it = t; ctx = App'' (e, c) } -> At { it = App(e, t); ctx = c }
    | At { it = t; ctx = If' (c, e1, e2) } -> At { it = If(t, e1, e2); ctx = c }
    | At { it = t; ctx = If'' (e1, c, e2) } -> At { it = If(e1, t, e2); ctx = c }
    | At { it = t; ctx = If''' (e1, e2, c) } -> At { it = If(e1, e2, t); ctx = c }

let left =
    function
    | At { ctx = Top } as x -> x
    | At { ctx = Abs' _ } as x -> x
    | At { ctx = App' _ } as x -> x
    | At { it = t; ctx = App'' (e, c) } -> At { it = e; ctx = App'(c, t) }
    | At { ctx = If' _ } as x -> x
    | At { it = t; ctx = If'' (p, c, e) } -> At { it = p; ctx = If'(c, t, e) }
    | At { it = t; ctx = If''' (p, e, c) } -> At { it = e; ctx = If''(p, c, t) }

let right =
    function
    | At { ctx = Top } as x -> x
    | At { ctx = Abs' _ } as x -> x
    | At { it = f; ctx = App' (c, e) } -> At { it = e; ctx = App''(f, c) }
    | At { ctx = App'' _ } as x -> x
    | At { it = t; ctx = If' (c, a, b) } -> At { it = a; ctx = If''(t, c, b) }
    | At { it = t; ctx = If'' (p, c, b) } -> At { it = b; ctx = If'''(p, t, c) }
    | At { ctx = If''' _ } as x -> x

// #nowarn "40" // Recursive values and weird F# runtime initialization "sanity" check
module Web =

    type Loc<'a> = At of at<'a>
    
    and at<'a> =
        { it: 'a
          down: Loc<'a> Lazy
          up: Loc<'a> Lazy
          left: Loc<'a> Lazy
          right: Loc<'a> Lazy }


    // These functions are too general ...
    let loc0 wv l0 = l0

    let loc1 wv l0 t1 =
        let rec l1 =
            lazy
                (At
                    { it = t1
                      down = wv l1 t1
                      up = l0
                      left = l1
                      right = l1 })

        l1

    let loc2 wv l0 t1 t2 =
        let rec l1 =
            lazy
                (At
                    { it = t1
                      down = wv l1 t1
                      up = l0
                      left = l1
                      right = l2 })

        and l2 =
            lazy
                (At
                    { it = t2
                      down = wv l2 t2
                      up = l0
                      left = l1
                      right = l2 })

        l1

    let loc3 wv l0 t1 t2 t3 =
        let rec l1 =
            lazy
                (At
                    { it = t1
                      down = wv l1 t1
                      up = l0
                      left = l1
                      right = l2 })

        and l2 =
            lazy
                (At
                    { it = t2
                      down = wv l2 t2
                      up = l0
                      left = l1
                      right = l2 })

        and l3 =
            lazy
                (At
                    { it = t3
                      down = wv l3 t3
                      up = l0
                      left = l2
                      right = l3 })

        l1

    let rec weave l0 =
        function
        | Var s -> l0
        | Abs (s, t1) -> loc1 weave l0 t1
        // let rec l1 =
        //     lazy At { it = t1
        //               down = weave l1 t1
        //               up = l0
        //               left = l1
        //               right = l1 }
        // l1
        | App (t1, t2) ->
            let rec l1 =
                lazy
                    (At
                        { it = t1
                          down = weave l1 t1
                          up = l0
                          left = l1
                          right = l2 })

            and l2 =
                lazy
                    (At
                        { it = t2
                          down = weave l2 t2
                          up = l0
                          left = l1
                          right = l2 })

            l1
        | If (t1, t2, t3) ->
            let rec l1 =
                lazy
                    (At
                        { it = t1
                          down = weave l1 t1
                          up = l0
                          left = l1
                          right = l2 })

            and l2 =
                lazy
                    (At
                        { it = t2
                          down = weave l2 t2
                          up = l0
                          left = l1
                          right = l2 })

            and l3 =
                lazy
                    (At
                        { it = t3
                          down = weave l3 t3
                          up = l0
                          left = l2
                          right = l3 })

            l1

    let top t =
        let rec r =
            lazy
                (At
                    { it = t
                      down = weave r t
                      up = r
                      left = r
                      right = r })

        r

module ReadWriteWeb =

    type Loc<'a> = At of at<'a>

    and at<'a> =
        { it: 'a
          fdown: 'a -> Loc<'a>
          fup: 'a -> Loc<'a>
          fleft: 'a -> Loc<'a>
          fright: 'a -> Loc<'a> }


    let down (At l) = l.fdown l.it
    let up (At l) = l.fup l.it
    let left (At l) = l.fleft l.it
    let right (At l) = l.fright l.it

    let loc0 wv fl0' = fl0'

    let loc1 wv fl0' =
        let rec fl1 t1 =
            At
                { it = t1
                  fdown = wv (upd fl1)
                  fup = (upd fl0')
                  fleft = (upd fl1)
                  fright = (upd fl1) }

        and upd fl t1' = fl t1'
        fl1

    let loc2 wv fl0' =
        let rec fl1 t1 t2 =
            At
                { it = t1
                  fdown = wv (upd fl1 t2)
                  fup = (upd fl0' t2)
                  fleft = (upd fl1 t2)
                  fright = (upd fl2 t2) }

        and upd fl t2 t1' = fl t1' t2

        and fl2 t1 t2 =
            At
                { it = t2
                  fdown = wv (upd' fl2 t1)
                  fup = (upd' fl0' t1)
                  fleft = (upd' fl1 t1)
                  fright = (upd' fl2 t1) }

        and upd' fl t1 t2 = fl t1 t2

        fl1

    let loc3 wv fl0' =
        let rec fl1 t1 t2 t3 =
            At
                { it = t1
                  fdown = wv (upd fl1 t2 t3)
                  fup = (upd fl0' t2 t3)
                  fleft = (upd fl1 t2 t3)
                  fright = (upd fl2 t2 t3) }

        and upd fl t2 t3 t1' = fl t1' t2 t3

        and fl2 t1 t2 t3 =
            At
                { it = t2
                  fdown = wv (upd' fl2 t1 t3)
                  fup = (upd' fl0' t1 t3)
                  fleft = (upd' fl1 t1 t3)
                  fright = (upd' fl3 t1 t3) }

        and upd' fl t1 t3 t2 = fl t1 t2 t3

        and fl3 t1 t2 t3 =
            At
                { it = t3
                  fdown = wv (upd'' fl3 t1 t2)
                  fup = (upd'' fl0' t1 t2)
                  fleft = (upd'' fl2 t1 t2)
                  fright = (upd'' fl3 t1 t2) }

        and upd'' fl t1 t2 t3 = fl t1 t2 t3

        fl1

    let rec weave fl0 =
        function
        | Var _ as v -> loc0 weave (fl0 v)
        | Abs (s, t1) -> loc1 weave (fun t1' -> fl0 (Abs(s, t1'))) t1
        | App (t1, t2) -> loc2 weave (fun t1' t2' -> fl0 (App(t1', t2'))) t1 t2
        | If (t1, t2, t3) -> loc3 weave (fun t1' t2' t3' -> fl0 (If(t1', t2', t3'))) t1 t2 t3

    let top =
        let rec fr t =
            At
                { it = t
                  fdown = weave fr
                  fup = fr
                  fleft = fr
                  fright = fr }

        fr

    type Weaver<'a> = W of (('a -> Loc<'a>) -> Loc<'a>)
    let unW (W f) = f

    let call wv fl0 t = unW (wv t) fl0

    let con0 wv k = W (fun fl0 -> loc0 (call wv) (fl0 k))
    let con1 wv k t1 = W
